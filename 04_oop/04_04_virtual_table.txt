============================== Step 2 ==============================
Таблица виртуальных методов

• Динамический полиморфизм реализуется при помощи таблиц виртуальных
методов.

• Таблица заводится для каждого полиморфного класса.

• Объекты полиморфных классов содержат указатель на таблицу
виртуальных методов соответствующего класса.

• Вызов виртуального метода --  это вызов метода по адресу из таблицы (в
коде сохраняется номер метода в таблице).
p->occupation(); // p->vptr[1]();

============================== Step 3 ==============================
struct Person {
  virtual ~Person() {} // Обязательно нужен, если будет наследование и
		       // полиморфная работа с виртуальными методами
  string name() const {return name_;} 
  virtual string occupation () const = 0; 
  ...
};
struct Student : Person {
  // хотя слово virtual  не указано явно, occupation является
  // виртуальным методом, потому что он таковым объявлен в базовом
  // классе Person 
  string occupation() const {return "student";} 
  virtual int group() const {return group_;}
  ...
};

============================== Step 4 ==============================
Построение таблицы виртуальных методов

struct Person {
  virtual ~Person() {} // не забывать!
  virtual string occupation () 
    ...
};

struct Teacher : Person {
  string occupation () {...} //  переопределяет чистый виртуальный
			     //  метод из Person
  virtual string course() {...} 
  ...
};

struct Professor : Teacher { 
  string occupation () {...} // переопределен от базового
  virtual string thesis() {...} 
  ...
};

============================== Step 5 ==============================
Виртуальные методы в конструкторе и деструкторе

struct Person {
  virtual string name() const {return name_;} 
  ... // гле-то тут обязательно должен быть виртуальный деструктор!
};

struct Teacher : Person {
  Teacher(string const& nm) : Person(nm) 
  { cout << name (); }
  ...
};

struct Professor : Teacher {
  string name() const {return "Prof. "+name_;}
  ... 
};

Professor p("Stroustrup"); // "Stroustrup"
// При этом -- вопреки ожиданиям -- вызывается метод name из базового
// класса Person, поэтому приставки Prof. нету!

// Конструкторы вызываются в обратном порядке: сначала конструктор
// класса Person, потом конструктор Teacher, а потом конструктор
// класса Professor 

// Поэтому конструктор класса Professor еще не вызван, а вызван
// конструктор класса Teacher, который и выводит в stdout имя без
// приставки Prof.

// А деструкторы вызываются в обратном порядке: Professor -> Teacher
// -> Person

============================== Step 6 ==============================

Source: virtable.cpp

============================== Step 7 ==============================

Задание повышенной сложности. Предполагаемое решение этого задания не
переносимо с точки зрения стандарта, однако оно проверено на различных
версиях компиляторов g++/clang++/msvc. Решение этого задания не
обязательно для получения диплома по этому курсу, однако мы считаем
его полезным, чтобы лучше понять как устроены виртуальные функции
внутри.

Вам требуется реализовать функцию, которая принимает на вход два
указателя на базовый класс Expression, и возвращает true, если оба
указателя указывают на самом деле на объекты одного и того же класса,
и false в противном случае.

Пользоваться typeid и dynamic_cast запрещено.

Sample Input:
There is no tests for this task

Sample Output:
OK

Memory Limit: 256 MB
Time Limit: 5 seconds 

Исходная сигнатура

bool check_equals(Expression const *left, Expression const *right)
{
    // put your code here
}

Source: check.cpp

