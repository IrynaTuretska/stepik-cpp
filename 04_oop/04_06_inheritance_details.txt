============================== Step 2 ==============================
Модификаторы при наследовании

При наследовании можно использовать модификаторы доступа:

struct A {};
struct B1 : public A {}; // все знают о наследовании, могут
       использовать методы и A и B, приводить указатели и ссылки
       производного класса к указателям и ссылкам на базовый класс
struct B2 : private A {}; // информации о наследовании от А доступна
       только внутри класса B, все приведения тоже только внутри класса
       
struct B3 : protected A {}; // вся инфа о методах базового класса
       доступна внутри метода B3 и в тех методах, которые будут
       наследовать от B3. Аналогично с приведениями

Для классов, объявленных как struct, по-умолчанию используется public,
для объявленных как class -- private.

Важно: отношение наследования (в терминах ООП) задаётся только
public-наследованием.

Использование private- и protected-наследований целесообразно, если
необходимо не только агрегировать другой класс, но и переопределить
его виртуальные методы.

============================== Step 3 ==============================
Переопределение private виртуальных методов

struct NetworkDevice {
  void send(void * data, size_t size) { // публичный невиртуальный
					// метод, не сможем
					// переопредилить его у
					// производных классов
    log("start sending"); 
    send_impl(data, size); // а этот сможем переопределить
    log("stop sending");
  }
  ... 
private:
  virtual void send_impl(void * data, size_t size) // к ней нельзя
						   // обратиться
						   // снаружи и из наследников
  {...} 
};

struct Router : NetworkDevice { 
private:
  void send_impl(void * data, size_t size) {...} // при вызове этой
						 // функции все равно
						 // будут запущены
						 // функции log из
						 // публичного
						 // невиртуального
						 // метода send
};

============================== Step 4 ==============================
Реализация чистых виртуальных методов

Чистые виртуальные методы могут иметь определения:

struct NetworkDevice {
  virtual void send(void * data, size_t size) = 0; // чистый абстрактный
  ...
};

void NetworkDevice::send(void * data, size_t size) { 
  ...
}

struct Router : NetworkDevice { 
private:
  void send(void * data, size_t size) { 
    // в такой записи этоневиртуальный вызов
    NetworkDevice::send(data, size);
  } 
};

============================== Step 5 ==============================
Интерфейсы

Интерфейс--  это абстрактный класс, у которого отсутствуют поля
, а все методы являются чистыми виртуальными.

 struct IConvertibleToString {
   virtual ~IConvertibleToString() {} // деструктор обязательно должен
				      // быть реализованным
   virtual string toString () const = 0;
 };

struct IClonable {
  virtual ~IClonable() {}
  virtual IClonable * clone() const = 0;
};

// Возвращаем копию объекта по указателю
// Происходит автоматическое преобразование IClonable в Person
struct Person : IClonable {
  Person * clone() {return new Person(*this);}
};

То есть в интерфейсе есть только набор чистых абстактных виртуальных
методов, но нет реализации! (кроме деструктора)

============================== Step 6 ==============================

Множественное наследование

В C++ разрешено множественное наследование.

struct Person {};
struct Student : Person {};
struct Worker : Person {};
struct WorkingStudent : Student , Worker {}; // будет сразу два
					     // наследования от класса
					     // Person, что может
					     // вести к
					     // рассинхронизации и
					     // ошибкам компиляции

Стоит избегать наследования реализаций более чем от одного класса,
 вместо этого использовать интерфейсы.

struct IWorker {};
struct Worker : Person , IWorker {};
struct Student : Person {};
struct WorkingStudent : Student , IWorker {}

Множественное наследование --  это отдельная большая тема.
