============================== Step 1 ==============================
Указатели

Указатель - это переменная, хранящая адрес некоторой ячейки памяти

Указатели являются типизированными

int i = 3; // переменная типа int
int * p = 0; // указатель на переменную типа int

Нулевому указателю (которому присвоено значение 0) не соответствует
никакая ячейка памяти

Оператор взятия адреса переменной &.

Оператор разыменования *.

p = &i; // укаатель p указывает на переменную i
*p = 10; // изменяется ячейча по адресу p, то есть i

============================== Step 3 ==============================
Передача параметров по указателю

Вместо значений типа int  будем передавать указатели

void swap(int * a, int * b) {
  int t = *a;
  *a = *b;
  *b = t;
}

int main() {
  int k = 10;
  int m = 20;
  swap(&k, &m);
  count << k << " " << m << endl; // 20 10
  return 0;
}

swap изменяет переменные k и m по указателям на них

============================== Step 4 ==============================
Массивы

Массив -- это набор однотипных элементов, расположенных в памяти друг
за другом, доступ к которым осуществляется по индексу

С++ позволяет определять массивы на стеке

int m[10] = {1, 2, 3, 4, 5}; // массив 1 2 3 4 5 0 0 0 0 0

Индексацяия массива начинается с 0, последний элемент массива длины n
имеет индекс (n - 1)

for (int i = 0; i < 10; i++) {
  cout << m[i] << ' ';
}
cout << endl;

============================== Step 5 ==============================
Связь массивов и указателей

Указатели позволяют передвигаться по массивам
Для этого используется арифметика указателей


int m[10] = {1, 2, 3, 4, 5};
int *p = &m[0]; // адрес начала массива
int *q = &m[9]; // адрес последнего элемента массива

(p + k) -- сдвиг на k ячеек типа int вправо
(p - k) -- сдвиг на k ячеек типа int влево
(q - p) -- количество ячеек между указателями
p[k] эквивалентно *(p + k)
m[3] эквивалентно 3[m]

============================== Step 6 ==============================
Примеры

1. Заполнение массива

int m[10] = {}; // изначально заполнен нулями
//           = &m[0] = &m[9]  
for (int * p = m; p <= m + 9; ++p){
  *p = (p - m) + 1;
}
// Массив заполнен числами от 1 до 10

2. Передача массива в функцию

int max_element(int * m, int size) {
  int max = *m;
  for (int i = 1; i < size; ++i) {
    if (m[i] > max) {
      max = m[i];
    }
  }
  return max;
}

============================== Step 7 ==============================


C-style строки.

В языке C строки представляли как массивы char-ов, которые
заканчиваются специальным символом ‘\0’ (по факту, это просто символ
со значением 0). C++ сохраняет (в основном) совместимость с языком C,
поэтому поддерживает работу с C-style строками.

Строковые литералы в С++ имеют тип массива, например, литерал “C-style
string” имеет тип const char[15] - 14 символов строки и нулевой
завершающий символ. Ключевое слово const в данном случае обозначает,
что изменять содержимое строки нельзя - это довольно плохая затея
пытаться менять содержимое литералов. Однако можно создать копию
строкового литерала, например, так:

char copy[15] = "C-style string";
Впрочем, размер массива указывать не обязательно - если массив
инициализируется сразу при создании, то компилятор может сам вычислить
размер массива:

char copy[] = "C-style string"; // размер массива 15 char-ов

(Подробнее про ключевое слово const будет рассказано на следующей
неделе.)

============================== Step 8 ==============================


У начинающих изучать C++ иногда возникает соблазн передавать массивы в
функции следующим образом:

void foo(int a[3]) { /* ... */ }

Однако, не смотря на то, что такой код будет компилироваться, работает
он не совсем так как ожидается. Например:

int a[1] = {};
foo(a);
// размер ни на что не влияет, void foo(int a[3]) тоже самое что и
// void foo(int a[]) 

Компилятор не увидит никаких проблем в коде выше, так как размерность
массива в определении функции будет просто проигнорирована. Хотя
программист написавший функцию foo, вероятно, ожидает, что в нее можно
будет передавать только массивы из 3 элементов.

Способ передавать в функцию массивы строго заданной длины существует и
мы покажем его вам далее, однако он довольно некрасив и имеет свои
ограничения и используются довольно редко.

Важно: при передаче в функцию массивы не копируются (т.е. на самом
деле передаётся указатель на массив).
