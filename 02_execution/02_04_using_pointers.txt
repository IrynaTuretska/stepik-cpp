============================== Step 1 ==============================

третья часть цикла for выполняется после каждой итерации (посмотрите как выразить цикл for через цикл while — я про это рассказывал на первой неделе).
При этом возвращаемое значение игнорируется (именно в возвращаемом значении разница у ++i и i++).

Т.е. циклы

for (int i = 0; i < 10; i++) {...}

и

for (int i = 0; i < 10; ++i) {...}

эквивалентны.
Разница только в том, что операции i++ потенциально
работает дольше, чем ++i (требуется скопировать и сохранить значение до
инкремента). Для встроенных типов это не очень важно, но для
пользовательских разница может быть довольно существенна.

============================== Step 2 ==============================
Два способа передачи массива

Функция для поиска элемента в массиве:
// 1
bool cointains(int * m, int size, int value) {
  for (int i = 0; i != size; ++i) {
    if (m[i] == value)
      return value;
  }
  return false;
}

// 2
// * p -- первый элемент массива, * q -- эдемент, следующий за
// последним элементом массива -- это нужно удобно, если передается
// пустой массив, не нужно дополнительных проверок
bool contains(int * p, int * q, int value) {
  for (; p != q; ++p) {
    if (*p == value)
      return true;
  }
  return false;
}

У второго варианта есть два преимущества:
1) Синтаксис как у алгоритмов в стандартной библиотеке С++
2) Быстрее работает: в первом случае m[i] соответствует &(m + i),
поэтому в первом случае кроме == есть операция сложения

============================== Step 3 ==============================
Возврат указателя из функции

Функция поиска максимума в массиве

int max_element(int * p, int * q) {
  int max = *p;
  for (; p != q; ++p) {
    if (*p > max)
      max = *p;
  }
  return max;
}

int m[10] = {...};
int max = max_element(m, m + 10); // указатель на начало и элемент
    	  		     	  // следующий за последним
cout << "Maximum = " << max << endl;

Возвращение **указателя** на максимальный элемент массива

int *  max_element(int * p, int * q) {
  int * pmax = p;
  for (; p != q; ++p) {
    if (*p > *pmax)
      pmax = *p;
  }
  return pmax;
}

int m[10] = {...};
int * pmax = max_element(m, m + 10); // 
cout << "Maximum = " << *pmax << endl;

============================= Step 4 ==============================

Возврат значения через указатель

bool max_element(int * p, int * q, int * res) {
  if (p == q)
    return false;
  *res = *p;
  for (; p! = q; ++p)
    if (*p > * res)
      *res = *p;
  return true;
}

int m[10] = {...};
int max = 0;
if (max_element(m, m + 10, &max))
   cout << "Maximum = " << max << endl;

============================== Step 5 ==============================
Объединение двух методов
Возврат значения через указатель на указатель

bool max_element(int * p, int * q, int ** res) {
  if (p == q)
    return false;
  *res = p;
  for (; p != q; ++p)
    if (*p > ** res)
      *res = p;
  return true;
}

int m[10] = {...};
int * pmax = 0;
if (max_element(m. m + 10, &pmax))
  count << "Maximum = " << *pmax << endl;

============================== Step 6 ==============================
Очень часто, при операции над строками, нам необходимо знать ее
размер. Для C-style строк размер нигде явно не хранится, но его можно
найти. Напишите функцию, которая считает размер C-style строки.

Sample Input:
C-style string

Sample Output:
14

Memory Limit: 256 MB
Time Limit: 5 seconds

Source: cstyle.cpp

============================== Step 7 ==============================

Другой полезной операцией над строками является конкатенация - склейка
двух строк в одну. Реализуйте функцию, которая добавляет в конец
первого строкового аргумента копию второго строкового
аргумента. Памяти в первой строке достаточно, чтобы сохранить ровно
обе строки, но не больше.

Sample Input:
Hello,
 World!

Sample Output:
Hello, World!

Memory Limit: 256 MB
Time Limit: 5 seconds

Source: concat.cpp

============================== Step 8 ==============================

Другая частая задача над строками это поиск подстроки (некоторого
слова или сочетания символов) внутри другой строки. Реализуйте
функцию, которая ищет заданную подстроку в строке и возвращает позицию
ее первого вхождения (помните, что в C++ принято считать начиная с 0),
если подстрока найдена, или -1, если такой подстроки нет.

Sample Input:

Hello, world!
ello

Sample Output:
1

Memory Limit: 256 MB
Time Limit: 5 seconds

Source: strstr.cpp

============================== Step 9 ==============================



Функции, которые вы написали, довольно полезны - их даже включили в
стандартную библиотеку языков C и C++. В стандартной библиотеке они
называются strlen, strcat и strstr (кроме названия есть еще несколько
незначительных изменений, но смысл остался тем же). Чтобы использовать
их в C++ подключите заголовок cstring:

#include <cstring>
char str[100] = "left part";
strcat(str, " right part");
size_t length = strlen(str);

Функция strcat не предоставляет никакого способа контроля за
переполнением массива, это может служить источником ошибок. Вместо нее
предпочитайте функцию strncat.

В стандартной библиотеке есть еще множество полезных функций -
используйте их, когда возможно, а не пишите свои функции.

============================== Step 10 ==============================


В стандартной библиотеке C++ есть еще много функций полезных при
работе с массивами (и не только). Например, одной из самых частых
задач с массивами является сортировка, отсортировать массив чисел по
возрастанию в C++ можно так:

#include <algorithm> //здесь объявлена функция sort
using namespace std;
int a[100] = { ... };
sort(a, a + 100);

Функция sort позволяет сортировать не только по возрастанию, и не
только числа. Строго говоря это не совсем функция, а шаблон функции, с
шаблонами вы познакомитесь дальше в этом курсе.

Есть в заголовочном файле algorithm, еще несколько полезных функций,
например, функции поиска максимального и минимального элемента:

int *minptr = min_element(a, a + 100);
int *maxptr = max_element(a, a + 100);

Обратите внимание, что функции возвращают не сами элементы, а
указатели на них.

Аналогичным образом вы можете использовать их для массивов любых
других типов, для которых справедливо сравнение с использованием
оператора <.
