============================== Step 2 ==============================
Ссылки

Нужны, чтобы исправить некоторые недостатки указателей

Являются "красивой оберткой" над указателями

// это указатели, а не локальные переменные!
void swap (int & a, int & b) {
     int t = b;
     b = a;
     a = t;
}

int main() {
 int k = 10;
 int m = 20;
 swap(k, m);
 cout << k << " " << m << endl; // 20 10
 return 0;
}

============================== Step 4 ==============================
Различия ссылок и указателей

1) Ссылка не может быть неинициализированной
int * p; // ok
int & l; // fail!

2) У ссылки нет нулевого значения
int * p = 0; // ok -- указатель никуда не указывает
int & l = 0; // fail!

3) Ссылку нельзя переинициализировать (ссылка это синоним переменной)
int a = 10, b = 20;
int * p = &a; // p указывает на a
p = &b; // p указывает на b
int & l = a; // l ссылается на a
l = b; // a присваивается значение b

4) Нельзя получить адрес ссылки или ссылку на ссылку
int a = 10;
int * p = &a; // p указывается на a
int ** pp = &p; // pp указывает на переменную p, которая в свою
       	    	// очередь указывает на переменную а

int & l = a; // l ссылается на a
int * pl = l // pl указывает на переменную a
int && ll = l // ошибка

5) Нельзя создавать массивы ссылок
int * mp[10] = {}; // массив указателей на int
int & ml[10] = {}; // ошибка

6) Для ссылок нет арифметики

============================== Step 6 ==============================
lvalue и rvalue

Выражения в С++ можно разделить на два типа:

1) lvalue -- выражения, значения которых являются ссылкой на
переменную/элемент массива, а значит, могут быть указаны слева от
оператора = 

2) rvalue -- выражения, значения которых являются временными и не
соответствуют никакой переменной/элементов массива

Указатели и ссылки могут указывать только на lvalue;
int a = 10, b = 20;
int m[10] = {1, 2, 3, 4, 5};
int & l1 = a; // OK
int & l2 = a + b; // ошибка
int & l3 = *(m + a/2); // OK - соответствует элементу массива m[a/2],
      	       	       // здесь m[6], т.к. a / 2 = 5
int & l4 = *(m + a/2) + 1; // Ошибка
int & l5 = (a + b > 10) ? a : b; // OK

============================== Step 7 ==============================
Время жизни переменной

int * foo() {
    int a = 10;
    return &a;
}

int * p = foo(); // мы используем некорректный адрес, возвращаемый
foo(), потому что переменная а является *локальной* и перестает
существовать после выхода из функции

int & bar() {
 int b = 20;
 return b;
}

int & l = bar(); // аналогично -- потому что работа с несуществующей
переменной 

============================== Step 8 ==============================



В качестве параметров функций могут выступать не только ссылки на
примитивные типы, но и ссылки, например, на массивы. Выглядеть ссылка
на массив из трех значений типа int в параметре функции будет
следующим образом:

void foo(int (&a)[3]) { /* ... */ }

Обратите внимание, что скобки вокруг параметра a в данной конструкции
обязательны - мы хотим передать ссылку на массив, а не массив ссылок.

Кажется, что такая конструкция не имеет особого смысла, ведь массивы
при передаче в функцию не копируются. Однако, такая конструкция
запрещает компилятору игнорировать размер массива. 

Например, следующий код не будет компилироваться:

int a[1] = {};
foo(a);

Компилятор g++ на это выдаст следующую ошибку:
error: invalid initialization of reference of type ‘int (&)[3]’ from
expression of type ‘int [1]’


Т. е. компилятор не может получить из массива из одного элемента
ссылку на массив из трех элементов, что и ожидалось.

============================== Step 9 ==============================

В C++ ссылки используются не только для передачи изменяемых параметров
в функции, но и для передачи в функции параметров, копирование которых
может быть дорогой операцией. Примерами типов, для которых копирование
может оказаться дорогим являются string, который вы уже могли видеть,
или классы контейнеры vector, list, map, set, с которыми вы еще не
встречались.

В случае если мы хотим избежать ненужного копирования при передаче
параметров, но не хотим позволять изменять параметр внутри функции, то
его следует передавать по константной ссылке:

int foo(string const &s) { /* нельзя менять значение s */ }

Для примитивных типов передача параметров по константной ссылке
возможна, но не имеет особого смысла.

Подробнее об этом мы расскажем на следующей неделе.

