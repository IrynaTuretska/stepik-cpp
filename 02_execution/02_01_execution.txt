============================== Step 3 ==============================

Сегментация памяти

ОЗУ, используемая в программе на С++ разделена на области двух типов:
1) сегменты данных (переменные, массивы)
2) сегменты кода (текстовые сегменты) -- хранится код программы
(защищаются от записи ОС)

При запуске программы выделаются два сегмента данных:
1) сегмент глобальных данных
2) стек (для локальных переменных)

В процессе работы могут выделяться и освободаться дополнительные
сегменты памяти.

!!! Обращение к адресу вне выделенных сегнментов -- ошибка времени
    выполнения (access violation, segmentation fault)

============================== Step 4 ==============================
В скомпилированном коде каждой функции соответствует отдельная секция

Адрес начала такой секции -- это адрес функции

Работа с данными на уровне байтов, информации о типах данных уже нет
(только на процессе компиляции)

В процессе выполнения адрес следующей инструкции зранится в
специальном регистре процессора IP (Instruction Pointer).

Команды выполняются последовательно, пока не встретится специальная
команда (например, вызов функции или условный переход), которая
изменит IP

============================== Step 5 ==============================
Линковка

На этапе компиляции объектных файлов в места вызова функций
подставляются имена функций

На этапе линковки в места вызова вместо имен функций подставляются их
адреса

Ошибки линковки:
 1) undifined reference
    Функция объявлена, но не имеет тела
 2) Multiple definition
    Функция объявлена 2 или более раз
    (Чаще всего такая ошибка бывает, когда функция определена в
    заголовочном файле, который подключен к нескольким *.cpp файлам)


============================== Step 6 ==============================
g++ -c main.cpp square.cpp
objdump -d main.o 
(gobjdump -d main.o или  otool -tv main.o

gobjdump -x main.o (таблица символов)

