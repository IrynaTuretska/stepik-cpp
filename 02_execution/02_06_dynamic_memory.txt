============================== Step 2 ==============================
Зачем нужна динамическая память?

Стек небольшой, не предназначен для хранения больших объемов данных

Время жизни локальных переменных ограничено временем работы функции

Динамическая память выделяется в сегменте данных

Структура, отвечающая за выделение дополнительной памяти, называется
кучей (не путать с одноименной структурой данных)

Выделение и освобождение памяти управляется вручную

============================== Step 3 ==============================
Выделение памяти в стиле С

Стандартная библиотека cstdlib:
void * malloc (size_t size);
void free (void * ptr);
void * calloc (size_t nmemb, size_t size);
void * realloc (void * ptr, size_t size);

size_t - специальный целочисленный беззнаковый тип, может вместить в
себя размер любого типа в байтах

void * указатель на нетипизированную память (раньше для этого
использовалось char *)

============================== Step 4 ==============================
malloc - выделяет область памяти размера >= size. Данные не
инициализируются 

calloc - выделяет массив из nmemb размера size. Данные
инициализируются нулем

realloc - изменяет размер области памяти по указателю ptr на size
(если это возможно, то это делается на месте, без копирования в другое
место)

free - освобождает область памяти, ранее выделенной одной из функций
malloc/calloc/realloc

============================== Step 5 ==============================
Для указание размера типа используется оператор sizeof

// создание массива из 1000 int
// (int *) приведение void * к инту
int * m = (int *) malloc(1000 * sizeof(int));
m[10] = 10; // теперь можно пользоваться указателем m как массивом

// изменение размера массива до 2000
m = (int *) realloc(m, 2000 * sizeof(int));

// освобождение массива
// после этого к m уже нельзя обращаться
free(m);

// создание массива нулей
m = (int *) calloc(3000, sizeof(int));

free(m);

m = 0; // признак хорошего стиля

============================== Step 6 ==============================
Выделение памяти в стиле C++
Два набора операторов для выделения памяти:

1) new и delete -- для одиночных значений
2) new [] и delete [] -- для массивов

Версия оператора delete должна соответствовать версии оператора new

// выделение памяти под один инт со значением 5
int * m = new int(5);
delete m; // освобождение памяти

// создание массива нулей
m = new int[1000];
delete [] m; // освобождение памяти

============================== Step 7 ==============================
Типичные проблемы при работе с памятью

1) Проблемы производительности: создание переменной на стеке
значительно дешевле, чем в динамической памяти

2) Проблема фрагментации: выделение большого количества небольших
сегментов способствует фрагментации памяти

3) Утечка памяти

// создание массива из 1000 int
int * m = new int[1000];

// создание массива из 2000 int
m = new int[2000]; // утечка памяти

// не вызван delete [] m, утечка памяти

============================== Step 8 ==============================
Неправильное освобождение памяти
int * m1 = new int[1000];
delete m1; // должно быть delete [] m1

int * p = new int(0);
free(p); // совмещение функций C++ и C

int * q1 = (int *)malloc(sizeof(int));
free(q1);
free(q1); // двойное удаление

int * q2 = (int *)malloc(sizeof(int));
free(q2);
q2 = 0; // обнуляем указатель
free(q2); // правильно работает для q2 = 0, поэтому после фрии всегда
          // желательно занулять указатель

============================== Step 9 ==============================


Посимвольный ввод.

Как упоминалось ранее, оператор чтения из потока (>>) обычно
игнорирует пробельные символы, иногда это не желательно. Для
организации посимвольного ввода используйте метод get потока ввода (о
методах мы поговорим на следующей неделе), как это показано в коде:
char c = '\0';
while (cin.get(c)) {
    /* ... */
}

Обратите внимание, что вызов метода происходит прямо в условии цикла
while. Так можно делать потому что, если чтение прошло удачно, метод
get возвращает значение, которое интерпретируется как истина, если же
чтение прошло не удачно (самая типичная ситуация, когда во входном
потоке больше не осталось символов), то метод get возвращает значение,
которое интерпретируется как ложь. 

============================== Step 10 ==============================
В этой задаче вам необходимо написать функцию getline, которая читает
строку из стандартного потока ввода cin. Конец строки достигается,
если прочитан символ '\n' или поток ввода прочитан полностью. Если
прочитан символ '\n', то сохранять его в строку не нужно. Не забудьте,
что строка должна оканчиваться нулевым символом. Всю выделенную
динамически память, кроме результирующей строки, необходимо освободить
- будьте внимательны! Указатель возвращенный из getline будет
освобожден с помощью delete[].

Замечания:

    выделяйте и освобождайте память в стиле C++,
    функция ничего не должна выводить (Sample Output в примере — это
    возвращаемое значении функции в формате длина возвращаемой
    строки:возвращаемая строка, длину в строке возвращать не нужно -
    эта информация для сведения).


Source: getline.cpp

