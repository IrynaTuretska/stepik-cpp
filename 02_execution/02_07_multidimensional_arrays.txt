============================== Step 2 ==============================
C++ позволяет определять многомерные массивы

// двумерный массив - 2 строки по 3 столбца
int m2d[2][3] = {{1, 2, 3}, {4, 5, 6}};
for (size_t i = 0; i != 2; ++i) {
    for (size_t j = 0; j != 3; ++j) {
    	cout << m2d[i][j] << ' ';
    }
    cout << endl;
}
// выведет: 1 2 3
//          4 5 6

Элементы m2d располагаются в памяти "по строчкам"

Размерность массивов может быть любой, но на практике редко используют
массивы размерности > 4

int m4d[2][3][4][5] = {};

============================== Step 3 ==============================
Динамические массивы

Для выделения одномерных динамических массивов обычно используется
оператор new []

int * m1d = new int[100];

Какой тип должен быть у указателя на двумерный динамически массив?
1) Пусть m - указатель на двумерный массив типа int
2) Значит m[i][j] имеет тип int (точнее int &)
3) m[i][j] - это *(m[i] + j), то есть типа m[i] - int *
4) Аналогично m[i] - это *(m + i), то есть тип m - int **

Чему соответствует значение m[i]?
Это адрес строки с номером i

Чему соответствует значение m?
Это адрес массива с указателями на строки

============================== Step 4 ==============================
Создание массива 5 х 4

int ** m = new int * [5];
for (size_t i = 0; i != 5; ++i) {
    m[i] = new int[4];
}

============================== Step 5 ==============================
Выделение и освобождение двумерного массива размера a x b

int ** create array2d(size_t a, size_t b) {
    int ** m = new int * [a];
    for (size_t i = 0; i != a ; ++i) {
        m[i] = new int[b];
    }
    return m;
}

void free_array2d(int ** m, size_t a, size_t b) {
     for (size_t i = 0; i != a; ++i) {
     	 delete [] m[i]
     }
     delete [] m;
}

При создании оператор new вызывается (a+1) раз -- массив несвязный
(фрагментация)

При удаления размерность b не нужна (используется только для
единообразности)

============================== Step 6 ==============================
Двумерные массивы: эффективная схема

int ** m = new int * [5];
m[0] = new int [5 * 4];
for (size_t i = 1; i != 5; ++i) {
    m[i] = m[i - 1] + 4; // поставить указатель как в предыдущем +
    	       	      	 // длина строки
}

============================== Step 7 ==============================
int ** create array2d(size_t a, size_t b) {
    int ** m = new int * [a];
    m[0] = new int[a * b];
    for (size_t i = 1; i != a ; ++i) {
        m[i] = m[i - 1] + b;
    }
    return m;
}

void free_array2d(int ** m, size_t a, size_t b) {
     delete [] m[0];
     delete [] m;
}

При создании массива оператор new вызывается всего 2 раза

При создании массивов большой размерности будут добавляться по одной
звездочке к указателю типа, по new delete

============================== Step 8 ==============================
Многомерные массивы в C++ можно создавать и на стеке, так же как и
обычные массивы:

int a[5][3];
cout << a[1][1] << " " << a[1][2] << endl;

Если массив будет сразу же инициализирован то его внешнюю размерность
можно не указывать:

int a[][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };

В примере выше будет создан массив 3 на 3 (3 массива по три элемента).

Так же многомерный массив можно инициализировать следующим образом,
казалось бы, необычным образом:

int a[][3] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

Дело в том, что многомерные массивы на стеке отличаются от показанных
вам многомерных массивов в динамической памяти - многомерный массив на
стеке хранится в непрерывном участке памяти.  На примере двумерного
массива:

int a[N][M];

сначала в памяти хранятся M элементов 0 строки, затем M элементов 1
строки, затем M элементов 2 строки и так далее до строки с номером N -
1 включительно. Поэтому второй пример инициализации массива
эквивалентен первому.

Пользуясь этим знанием, мы можем понять, что следующий код для
двумерного массива a:

*((int *)a + i * M + j) = 1;

эквивалентен такому присваиванию:

a[i][j] = 1;


============================== Step 9 ==============================

Напишите функцию, которая принимает на вход прямоугольную матрицу
размера m на n (двумерный массив в динамической памяти из m строк и n
столбцов), ищет строку содержащую минимальный элемент и меняет ее
местами с первой строкой матрицы. При решении задачи вы можете
заводить любые вспомогательные функции.

Source: swapmin.cpp

============================== Step 10 ==============================


Реализуйте функцию транспонирования прямоугольной матрицы. Т. е. на
вход подается двумерный массив (m), количество строк в нем (r) и
количество столбцов (c), требуется выделить память под двумерный
массив (mt), в котором будет c строк и r столбцов, и заполнить его
таким образом, чтобы mt[i][j] == m[j][i]. При этом изменять исходный
массив нельзя.

Source: transpose.cpp
