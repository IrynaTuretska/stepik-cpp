============================== Step 1 ==============================
Стек вызово -- это сегмент данных, который используется для зранения
локальных переменных и временных значений

Стек выделяется при запуске программы

Обычно стек небольшой по размеру (4Мб)

Функции зранят свои локальные переменные на стеке

При выходе из функции соответствующая область стека объявляется
свободной

Промежуточные значения, возникающие при вычислении сложных выражений,
также хранятся на стеке.

============================== Step 3 ==============================
В архитектуре х86 стек растет сверху вниз -- от самого большого адреса
к самому маленькому. Дно стека находится сверху, вершина -- снизу

============================== Step 4 ==============================
Вызов функции

Два счетчика при выполнении программы:
1) Frame pointer (начало данных, которое соответствует текущей функции)
2) Stack pointer (вершина стека)

============================== Step 5 ==============================
Вызов функции

1) При вызовые функции на стек складываются:
 1. Аргументы функции
 2. Адрес возврата
 3. Значение Frame Pointer и регистров процессора

2) На стеке резервируется место под возвращаемое значение

Параметры передаются в обратном порядке, что позволяет реализовать
функции с переменным числом аргументов

Адресация локальных переменных функции и аргументов функции происходит
относительно frame porinter

Конкретный процесс вызова зависит от используемых соглашений (cdecl,
stdcall, fastcall, thiscall)

============================== Step 7 ==============================
С++ позволяет создавать рекурсивные функции, т. е. функции которые
вызывают сами себя напрямую или опосредовано. Например, следующая
функция вычисляет факториал:

int factorial(int n) {
    if (n == 0)
        return 1;
    return factorial(n - 1) * n;
}

Язык C++ не рассчитан на написание программ активно использующих
рекурсию, но некоторые вещи очень естественно выражаются рекурсивно.

Максимальную глубину вложенности рекурсивных вызовов мы будем называть
глубиной рекурсии, например, для описанной выше функции факториала,
если ее вызвать с параметром 0, то глубина рекурсии будет равна 1
(т. е. функция факториала вызвана всего один раз), а для параметра 3
глубина будет равна 4: мы вызываем factorial(3), который вызывает
factorial(2), который вызывает factorial(1), который вызывает
factorial(0), который просто возвращает 1, т. е. всего 4 вызова.

Рекурсия может быть и более сложной, например, следующая функция
вычисляет число Фибоначчи с заданным номером:

int fibonacсi(int n) {
    if (n < 2)
        return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

Т. е. рекурсивные вызовы могу образовывать дерево, узлами которого
являются вызовы функции с конкретными параметрами, а глубина рекурсии
это высота этого дерева. Например, для вызова fibonacci(3) глубина
рекурсии будет равна 3 (нарисуйте это дерево самостоятельно и
убедитесь, что самая длинная цепочка в дереве выглядит так:
fibonacci(3) -> fibonacci(2) -> fibonacci(1)).

============================== Step 9 ==============================

int foo(int n) {
    if (n <= 0)
        return 2;
    return foo(n - 1) + foo(n / 2);
}

Какова будет глубина рекурсии, если вызвать эту функцию с аргументом 3
(foo(3))?

Ответ: 4

============================== Step 10 ==============================
На стандартный вход программе подается последовательность разделённых
пробелами положительных целых чисел, заканчивающаяся нулем. Требуется
вывести эту же последовательность в обратном порядке (без нуля),
разделяя числа пробелами. При этом запрещается использовать массивы
(даже если вы с ними уже знакомы). (Подсказка: воспользуйтесь
рекурсией).

Sample Input:
1 2 3 4 0

Sample Output:
4 3 2 1

Memory Limit: 256 MB
Time Limit: 5 seconds
