============================== Step 2 ==============================
Определение констант

double const pi = 3.1415926535;
int const day_seconds = 24 * 60 * 60;
// массив констант
int const days[12] = {31, 28, 31,
		      30, 31, 30,
		      31, 30, 31};

Попытка изменить константные данные приводит к непоределенному поведению
int * may = (int *) &days[4]; // берем адрес 4-го значения, 
      	    	    	      // получаем указатель на ячейку
*may = 30; // может быть ошибка

============================== Step 3 ==============================
Указатели и const

В С++ возможно определить как константный указатель, так и указатель
на константу

int a = 10;
const int * p1 = &a; // указатель на константу
int const * p2 = &a; // указатель на константу

*p1 = 20; // ошибка
p2 = 0; // OK

int * const p3 = &a; // константный указатель
*p3 = 30; // OK
p3 = 0; // ошибка

// константный указатель на константу
int const * const p4 = &a;
*p4 = 30; // ошибка
p4 = 0; // ошибка

============================== Step 4 ==============================
Указатели и const

Можно использовать следующее правило:
*** слово const делает неизменяемым тип слева от него ***
int a = 10;
int * p = &a;

// указатель на указатель на const int
int const ** p1 = &p;

// указатель на константный указатель на int
int * const * p2 = &p;

// константный указатель на указатель на int
int ** const p3 = &p;

============================== Step 5 ==============================
Очень внимательные слушатели могли заметить, что на предыдущем слайде
я допустил ошибку. Если Вы не заметили, но считаете, что хорошо знаете
C++, то не читайте дальше, а попробуйте сначала найти её и объяснить,
почему это ошибка.

Ошибка заключается следующем присваивании: int const ** p1 = &p;  В
данной строчке я ожидаю, что значение типа int ** (адрес переменной p)
приведётся к значению типа int const **.
Если Вы попробуете скомпилировать этот код, то увидите, что он
приводит к ошибке компиляции. Почему? Потому, что стандарт запрещает
такие преобразования. Говоря точнее, стандартом разрешены (неявные)
преобразования от T * к T const *, но не T ** к T const **.

Почему бы не разрешить такие преобразования?

Оказывается, что, если бы такие преобразования были разрешены, то
можно было бы изменить константные данные. Другими словами, система
константности C++ была бы некорректна — она позволяла бы изменять
неизменяемые данные.

Вопрос: как с помощью преобразования вида T ** к T const ** можно было
бы изменить константные данные (если бы C++ позволял такие
преобразования)?

Попытайтесь сначала сами найти ответ на этот вопрос. Получилось? Вот
как это можно сделать:
int const i = 1;
int * p = 0;
// p = &i;  не скомпилируется, т.к. это преобразование int const * ->
int *

// В этой строке происходит запрещённое преобразование int ** -> int
const **
int const ** pp = &p; // теперь *pp указывает на переменную p

// следующая строка скомпилируется, т.к. *pp имеет тип int const*
*pp = &i; // это соответствует p = &i;
*p = 2; // изменяем значение переменной i 

============================== Step 6 ==============================
Ссылка сама по себе является неизменной
int a = 10;
int & const b = a; // ошибка
int const & c = a; // ссылка на константу

Использование константных сылок позволяет избежать копирования
объектов при передаче в функцию

Point midpoint(Segment const & s);

По константной ссылке можно передавать rvalue

Point p = midpoint(Segment(Point(0, 0),
			   Point(1, 1)));

============================== Step 7 ==============================

Методы классов могут быть объявлены как const

struct IntArray {
  size_t size() const;
};

Такие методы не могут менять поля объекта (тип this -- указатель на
const)

У константных объектов (через указатель или ссылку на константу) можно
вызывать только константные методы

IntArray const * p = foo();
p->resize(); // error

Внутри константных методов можно вызывать только константные методы

============================== Step 8 ==============================

Слово const является частью сигнатуры методы

size_t IntArray::size() const { return size_; }

Можно определить две версии одного метода

struct IntArray {
  int get(size_t i) const {
    return data_[i]; // возвращает константу инт
  }
  int & get(size_t i) {
    return data_[i]; // возвращает ссылку на значение
  }
private:
  size_t size_;
  int * data_;
};

============================== Step 30 ==============================
Синтаксическая константность: константные методы не могут менять поля
объектов (обеспечивается компилятором)

Логическая константность: нельзя менять те данные, которые определяют
состояние объекта

struct IntArray {
  void foo() const {
    // нарушение логической константности
    data_[10] = -1;
  }
private:
  size_t size_;
  int * data_;
};

============================== Step 10 ==============================
Ключевое слово mutable

Ключевое слово mutable позволяет определять поля, которые можно
изменить внутри константных методов:

struct IntArray {
  size_t size() const {
    ++counter_;
    return size_;
  }
private:
  size_t size_;
  int * data_;
  mutable size_t counter_;
};

============================== Step 11 ==============================

int compare(String &str) 
size_t size() 
const char *c_str() 


============================== Step 12 ==============================

Перепишите объявление метода append, с учетом того, что параметр метода не должен изменяться?
Исходное объявление выглядит так:
void append(String &str);

Ответ:
void append(const String &str) const;



============================== Step 13 ==============================
Перепишите объявление метода compare так, чтобы учесть, что метод не
изменяет ни состояние самого объекта, ни параметр, переданный в этот
метод.

Исходное объявление выглядит так:

int compare(String &str);

Ответ: int compare(const String &str) const;


============================== Step 14 ==============================
Добавьте в класс String еще один метод с именем at, который можно
вызывать на константном объекте (имеется ввиду логическая
константность).

Ответ:
  // 3.6.14
  char at(const size_t idx) const {
    // here
    return str_[idx];
  }

