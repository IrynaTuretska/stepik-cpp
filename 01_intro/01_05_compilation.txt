============================== Step 1 ==============================
Для дальнейшего прохождения курса вам понадобится компилятор С++. Их
существует огромное количество, вот далеко не полный список:

    g++ - компилятор C++ из GCC (используется платформой stepic.org);
    clang++ - компилятор C++ на базе проекта LLVM; Microsoft Visual
    Studio - IDE и компилятор С++ (и не только) от компании
    Mircrosoft; Intel C++ Compiler - версия компилятора от компании
    Intel; Oracle Solaris Studio - IDE и компилятор C++ (и не только)
    от компании Oracle.

Все они в разной степени поддерживают стандарты языка C++ и не всегда
совместимы друг с другом (стандарты языка C++ оставляют компиляторам
довольно много свободы).

Пока вы остаетесь в рамках ISO/IEC 14882:2003 (С++ 2003) проблем со
сдачей решений у вас возникнуть не должно - можете выбрать любой из
них.

Чтобы установить компилятор вы можете обратиться к краткому
руководству по установке компиляторов и сборке программ или
воспользоваться google/yandex/bing/любой другой поисковой системой.

Во время прохождения этого курса мы настоятельно не рекомендуем вам
пользоваться IDE, а обходится простым текстовым редактором (vim,
emacs, notepad, gedit или любой другой на ваш вкус) и собирать проекты
из командной строки.

============================== Step 3 ==============================
Этапы компиляции программы:
I. Препроцессор (обработка директив)

Директива #include позволяет подключать заголовочные файлы к файлам
кода:
1) #include <foo.h> -- библиотечный заголовочный файл
2) #include "bar.h" -- локальный заголовочный файл

II. Собственно компиляция
(на выходе получаем объектный файл)

III. Линковка (компоновка)
Все объектные файлы объединяются в один исполняемый (или библиотечный)
файл.
При этом происходит связывание имен функций с их адресами в уже
скомпилированном коде.

По каждому объектному файлу строится таблица всех функций, которые в
нем определены. Дальше проходимся по всем объектным файлам и в местах
выхова функций подставляется адрес этой функции.

Еще на этом этапе определяется точка входа (функция, с которой
начинается выполнение программы -- main с параметрами или без)

int main ()
{
	return 0;
}

int main(int argc, char ** argv) 
{
	return 0;
}

Если 0 -- то программа отработала без ошибок, если не ноль, то с
ошибкой.

============================== Step 7 ==============================
Имеем три файла: main.cpp, square.cpp, square.hpp

Вызов только препроцессора:
g++ -E square.cpp -o square_prepocessor.cpp

То же самое с файлом main.cpp
g++ -E main.cpp -o main_prepocessor.cpp

main_prepocessor.cpp содержит не только содержимое main.cpp, но и
объявление функции square из заголовочного файла square.hpp

А теперь непосредственно компиляция
g++ -С square.cpp (получаем объектные файлы square.o)
g++ -С main.cpp (main.o)

Для получения исполняемого файла:
g++ square.o main.o -o program

Можно все шаги объединить в один:
g++ main.cpp square.cpp -o program1

Выдать программу в виду ассемблерного кода (square.s):
g++ -S sqaure.cpp

Можно видеть, как в ассемблерном коде изменились названия функция
(приведенные к уникальному виду):
__Z6squarei -- означает, что 6 букв в названии функции и она принимает
параметр int

Обратное преобразование функции (возвращает изначальную сигнатуру функции):
c++filt -n _Z6squarei

