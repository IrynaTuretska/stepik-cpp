============================== Step 3 ==============================
Основные операторы

Арифметические
• Унарные: префиксные + - ++ --, постфиксные ++ -- 
• Бинарные: + - * / % += -= *= /= %=

int a = 10;
a = -a; // -10
int b = ++a; // b = -9
b = a++; // b = -9, а после присваивания a = -8

Префиксный ++ сначала изменяет значение переменной, а потом возвращает
ее значение
Постфиксный оператор сначала возвращает значение переменной, а потом
ее изменяет

Битовые
• Унарные: ~. (010110, ~ => 101001)
• Бинарные: & | ^ &= |= ^= >> <<.
^ - XOR
>> - сдвиг вправо

Логические (для типа bool)
• Унарные: !.
• Бинарные: && ||.
• Сравнения: == != > < >= <=

x xor y => x != y

============================== Step 4 ==============================
Другие операторы

1. Оператор присваивания: = 
2. Специальные:
  • префиксные * &,
  • постфиксные -> ->*, • особые , . :: (:: доступ к пространству
  имен, например, при доступе к методу вне класса)

b = (a+= c, a + d); // b присвоится a + d, но до этого a будет
установлено в a = a + c

3. Скобки: [] ()

4. Оператор приведения (type)

есть два объекта разных классов A и B
A(B) означает приведение B -> A

5. Тернарный оператор: x ? y : z
6. Работа с памятью: new new[] delete delete[]

Нельзя перегружать операторы . :: и тернарный оператор.

============================== Step 5 ==============================
Перегрузка операторов

// унарный минус
Vector operator-(Vector const& v) { 
  return Vector(-v.x, -v.y)
}

// сложение, бинарный оператор
Vector operator+(Vector const& v,
       	         Vector const& w) {
  return Vector(v.x + w.x, v.y + w.y);
}

// умножение вектора на число
Vector operator*(Vector const& v, double d) {
  return Vector(v.x * d, v.y * d);
}

// умножение числа на вектор, выполняется с помощью предыдущей
// перегрузки
// перегрузить этот оператор не снаружи, как здесь, а внутри
// какого-нибудь класса не получится, потому что первым аргументом
// идет встроенный тип double
Vector operator*(double d, Vector const& v) { 
  return v * d;
}

============================== Step 6 ==============================
Перегрузка операторов внутри классов

NB: Обязательно для (type) [] () -> ->* =
Их снаружи нельзя перегружать, только внутри класса

struct Vector {
  Vector operator-() const { return Vector(-x, -y); } // это унарный
//  оператор, определенный в методе. У него ноль аргументов, потому
//  что подразумевается аргумент this
  Vector operator -(Vector const& p) const { // бинарный оператор, но
//  аргумент один, потому что второй this, он неявный
    return Vector(x - p.x, y - p.y);
￼￼}
// это *= (Vector, double)
Vector operator *=( double d) {
  x *= d;
  y *= d; 
  return *this;
}
// обращение к координате вектора V[0] - x, V[1] - y
double operator []( size_t￼i) const {
  return (i == 0) ? x : y;
}
bool operator ()( double d) const { ... }
void operator()(double a, double b) { ... } 
double x, y;
};

============================== Step 7 ==============================
Перегрузка инкремента и декремента

struct BigNum {
  // унарный оператор, поэтому ноль аргументов
  BigNum & operator ++() { //prefix
    // increment
    ...
    return *this; // ссылка на текущий объект
  }
  // чтобы отличать постфиксный оператор от префиксного, используется
  // dummy параметр, например, int, который никак не используется,
  // поэтому там даже нет имени, а просто int
  BigNum operator++(int) { //postfix 
    BigNum tmp(*this); // a = 10; b = a++; b = 10, a = 11
    ++(* this );
    return tmp; // значение, а не ссылка
  } 
  ... 
};

============================== Step 8 ==============================
Переопределение операторов ввода-вывода

#include <iostream >

struct Vector { ... };

std::istream& operator >>(std::istream & is,
	      	                  Vector & p) {
  is >> p.x >> p.y;
  return is;  // поток ввода
}


std::ostream& operator <<(std::ostream &os, 
   	      	          Vector const& p) {
  os << p.x << ’ ’ << p.y;
  return os; 
}

Перегрузка ввода-вывода должна делаться только вне класса, потому что
иначе надо было бы менять iostream, который мы менять не можем -- они
описаны где-то внутри стандартной библиотеки.

============================== Step 9 ==============================
Умный указатель

Реализует принцип: “Получение ресурса есть инициализация” 
Resource Acquisition Is Initialization (RAII)

struct SmartPtr {
  Data & operator*() const {return *data_;} // * должен возвращать
  // ссылку на объект Data
  Data * operator ->() const {return data_;} // возвращает указатель
  Data * get() const {return data_;}
  ...

private:
  Data * data_;
};

bool operator==(SmartPtr const& p1, 
                SmartPtr const& p2) {
  return p1.get() == p2.get(); 
}



a->x трактуется компилятором как (a.operator->())->x, именно поэтому
мы просто возвращаем указатель data_

============================== Step 10 ==============================
Оператор приведения (type casting)

A -> B
Нужен, когда мы никак не можем влиять на тип B.
В противном случае мы могли бы задать в B конструктор от значения типа
A. 

В его сигнатуре не указывается возвращаемое значение, как в обычных
методов.

Должен быть определен именно в другом

struct String {
  // приводим String к bool
  operator bool() const {
    return size_ != 0; 
  }
  // приведение от String к строке в стиле C, т.е. char const *
  operator char const *() const { 
    // если строка не пуста, возвращаем ее
    if (*this)
      return data_;
    // иначе возвращаем пустую строку
    return "";
}

private:
  char * data_;
  size_t size_; 
};

============================== Step 11 ==============================
Операторы с особым порядком вычисления
"&&", "||", ","

0 -> false
все остальное преобразуется к true

int main() {
  int a = 0;
  int b = 5;
  (a != 0) && (b = b / a); // если бы вмето && был +, то сначала
  // вычислялись бы скобки, а потом уже +. А для && сначала
  // вычисляется первая скобка, если она true, то вычисляется вторая
  // скобка (такой порядок вычисления называется short circuit
  // logic). Выражение вернет false. А в случае + была бы ошибка
  // деления на ноль.

  (a == 0) || (b = b / a); // первая скобка даст true, поэтому вторая
  // скобка не вычисляется

  foo () && bar ();
  foo () || bar ();
  foo(), bar(); // сначала вычисляется foo(), а потом bar()
  // a = foo(), bar(); // в а будет лежать значение из bar(), foo()
  // вычислится, но никуда не присвоится
}

// no lazy semantics
Tribool operator&&(Tribool const& b1, 
	           Tribool const& b2) {
  ... 
}

При перегрузке этих операторов особый порядок вычисления не будет
гарантироваться! Напротив, сначала будут вычисляться операнды, а
только потом оператор, как в примере с Tribool operator&&.


