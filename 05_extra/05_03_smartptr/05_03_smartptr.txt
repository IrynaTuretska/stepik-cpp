============================== Step 2 ==============================
В разговоре о перегрузке операторов мы упомянули умные
указатели. Вообще, умные указатели — это тема, которой стоит уделить
отдельный урок.

В предыдущих неделях вы уже могли набить достаточно шишек на ручном
управлении памяти, чтобы задуматься о более разумном подходе. Начнем с
довольно простого случая — динамические объекты, время жизни которых
ограничено блоком ({} - ограничивают блок в C++). Удобно сохранить
такой указатель в объекте, выделенном на стеке, а в деструкторе этого
объекта вызвать delete. Так как деструктор объекта, созданного на
стеке, вызывается автоматически при выходе из блока, то delete тоже
будет вызван автоматически.

Такой класс-обертку мы будем называть ScopedPtr. Стоит заметить, что
копирование такого объекта может приводить к серьезным проблемам,
например, к повторному освобождению памяти (два объекта хранят внутри
один, и тот же указатель и вызов delete будет сделан дважды). Поэтому
нужно запретить вызов конструктора копирования и оператора
присваивания таких объектов. Чтобы этого добиться, можно объявить их в
private секции класса. При этом даже не нужно их реализовывать —
снаружи класса никто не сможет их вызвать, а внутри класса мы этого
делать не будем.

Какой интерфейс может быть у такого класса ScopedPtr? Кроме уже
известных вам операторов * и ->, деструктора и конструктора, полезными
могут оказаться следующие методы:

    get - возвращает указатель, сохраненный внутри ScopedPtr
    (например, чтобы передать его в какую-то функцию);

    release - забирает указатель у ScopedPtr и возвращает значение
    этого указателя, после вызова release ScopedPtr не должен
    освобождать память (например, чтобы вернуть этот указатель из
    функции);

    reset - метод заставляет ScopedPtr освободить старый указатель, а
    вместо него захватить новый (например, чтобы переиспользовать
    ScopedPtr, так как оператор присваивания запрещен).

============================== Step 3 ==============================
Реализуйте ScopedPtr, как было описано ранее (реализуйте методы get и
release, операторы * и ->, а также конструктор от указателя на
Expression). Hint: в качестве признака того, что ScopedPtr не хранит
никакого указателя (после вызова release), используйте нулевой
указатель, при этом вы можете явно проверить указатель в деструкторе,
но это не обязательно, так как delete от нулевого указателя ничего не
делает.

Sample Input:
There are no tests for this task

Sample Output:
OK

Memory Limit: 256 MB
Time Limit: 5 seconds 

Signature:

struct Expression;
struct Number;
struct BinaryOperation;
struct FunctionCall;
struct Variable;

struct ScopedPtr
{
    // реализуйте следующие методы:
    //
    // explicit ScopedPtr(Expression *ptr = 0)
    // ~ScopedPtr()
    // Expression* get() const
    // Expression* release()
    // void reset(Expression *ptr = 0)
    // Expression& operator*() const
    // Expression* operator->() const


private:
    // запрещаем копирование ScopedPtr
    ScopedPtr(const ScopedPtr&);
    ScopedPtr& operator=(const ScopedPtr&);

    Expression *ptr_;
};

Source: scoped.cpp

============================== Step 4 ==============================
Для ScopedPtr мы запретили копирование, однако, копирование можно и
разрешить. Это позволит реализовать более продвинутый умный указатель
- SharedPtr. SharedPtr отличается от ScopedPtr тем, что кроме хранения
указателя на объект, он хранит еще и счетчик ссылок (количество
объектов SharedPtr, которые хранят один и тот же указатель).

Имея такой счетчик, мы можем определить момент, когда на объект,
выделенный в куче, не останется больше ссылок (когда счетчик ссылок
станет равным 0), и освободить память.

Поддержка счетчика ссылок состоит из нескольких частей:

    в конструкторе SharedPtr от ненулевого указателя мы инициализируем
    счетчик ссылок в 1 (конструктор создает первый SharedPtr, который
    хранит указатель)
    в конструкторе копирования мы увеличиваем счетчик ссылок на 1,
    если копируемый SharedPtr содержит ненулевой указатель
    (конструктор копирования создает еще один SharedPtr с указателем
    на тот же самый объект)
    в деструкторе мы уменьшаем значение счетчика на 1, если в объекте
    SharedPtr хранится ненулевой указатель (мы удаляем один SharedPtr,
    который указывает на объект в куче)
    оператор присваивания уменьшает счетчик ссылок левого операнда на
    1, если внутри левого SharedPtr хранится ненулевой указатель,
    увеличивает счетчик правого SharedPtr на 1, если в правом
    SharedPtr хранится ненулевой указатель (обычное дело для оператора
    присваивания - сначала освобождаем старые ресурсы, потом выделяем
    новые, но при этом нужно быть особенно внимательным с
    присваиванием самому себе)

Для класса SharedPtr могут оказаться полезными следующие методы (кроме
операторов * и ->, конструктора копирования, оператора присваивания,
деструктора и конструктора):

    метод get, как и в случае со ScopedPtr;
    метод reset - аналогичен reset у ScopedPtr, но освобождает память,
    только если счетчик ссылок после декремента равен 0;


============================== Step 6 ==============================

Задание повышенной сложности. Реализуйте класс SharedPtr как описано
ранее. Задание немного сложнее, чем кажется на первый взгляд. Уделите
особое внимание "граничным случаям" - нулевой указатель, присваивание
самому себе, вызов reset на нулевом SharedPtr и прочее. Hint:
возможно, вам понадобится завести вспомогательную структуру.

Sample Input:
There are no tests for this task

Sample Output:
OK

Memory Limit: 256 MB
Time Limit: 5 seconds 

Signature:

struct Expression;
struct Number;
struct BinaryOperation;
struct FunctionCall;
struct Variable;

struct SharedPtr
{
    // реализуйте следующие методы
    //
    // explicit SharedPtr(Expression *ptr = 0)
    // ~SharedPtr()
    // SharedPtr(const SharedPtr &)
    // SharedPtr& operator=(const SharedPtr &)
    // Expression* get() const
    // void reset(Expression *ptr = 0)
    // Expression& operator*() const
    // Expression* operator->() const
};

Source: shared.cpp

