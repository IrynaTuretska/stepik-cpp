============================== Step 2 ==============================
Глобальные переменные
Объявление глобальной переменной:

extern int global; // Объявление лучше хранить в файле *.hpp
void f () { 
  ++global;
}

Определение глобальной переменной:

int global = 10; // если опустить инициализацию, то будет
      	         // проинициализированная 0

Определение глобальной переменной должно быть в файле с кодом *.cpp

Проблемы глобальных переменных: 
• Масштабируемость. // коллизии в многопоточности
• Побочные эффекты. // мутации. Функция может при одном и том же входе
// давать разные значения, т.к. ответ может быть связан с глобальной пер.
• Порядок инициализации. // например, где-то определено int G = 50,
// а где-то есть int global = 10 + G; Она может определиться в 60, а
// может в неопределенной значение -- в зависимости от порядка инициализации

Единица трансляции -- файл проекта

============================== Step 3 ==============================
Статические глобальные переменные

Статическая глобальная переменная --  это глобальная переменная,
доступная только в пределах модуля (файла).

Определение:

static int global = 10;
void f () { 
  ++global;
}

Если в других модулях определить другие статические глобальные
переменные с тем же именем, то никаких проблем не будет.

Проблемы статических глобальных переменных: 
• Масштабируемость. // коллизии
• Побочные эффекты. // мутация

Глобальные и статические глоабльные переменные -- это плохой стиль.

============================== Step 4 ==============================
Статические локальные переменные

Статическая локальная переменная --  это глобальная переменная,
доступная только в пределах функции.

Время жизни такой переменной --  от первого вызова функции next до конца
программы.

int next(int start = 0) { 
  static int k = start; // static int k = g(); функция g() будет
  // вызвана только при первом вызове next(). В следующие разы эта
  // строчка будет игнорироваться
  return k++;
}

next(10); -> 10
next(20); -> 11, так как переменная уже была проинициализирована в прошлый раз

Проблемы статических локальных переменных: 
• Масштабируемость.
• Побочные эффекты.

============================== Step 5 ==============================
Статические функции

Обычная функция ведет себя как глоабальная (при условии объявления во
всех модулях), а статическая доступна только в пределах одного файла,
где она определена. Обычную функцию тоже можно определять с ключевым
словом extern, хотя в этом нет смысла и она и так ведет себя как
глоабальная.

Статическая функция, доступная только в пределах модуля. 

Файл 1.cpp:
static void test () { 
  cout << "A\n";
}

Файл 2.cpp:
static void test () { 
  cout << "B\n";
}

Статические глобальные переменные и статические функции проходят
внутреннюю линковку.

А обычные функции проходят внешнюю линковку.

============================== Step 6 ==============================
Статические поля класса

Статические поля класса --  это глобальные переменные, определённые
внутри класса.

Объявление:
struct User { 
  ...
private:
  static size_t instances_;
};

Допустим, у нас есть класс User, и мы хотим иметь возможность
посчитать, сколько всего объектов User существует в данный
момент. Тогда можно использовать статическое поле класса. В
конструктора инкрементировать instances_, а в деструкторе
декрементировать. Это лучше, чем просто глобальная переменная, потому
что глобальную переменую можно изменять из других частей программы.
А статическое поле можно изменять только через класс User.

Статические поля класса нужно определять в одной из единиц трансляции,
снаружи класса.

Определение:
size_t User::instances_ = 0;

Для доступа к статическим полям не нужен объект. Т.к. статическое поле
хранится в области глоабльных данных.

Если бы в примере instances_ было бы public, то мы могли бы вне класса
делать с переменной что угодно, например, присваивать значения
size_t User::instances_ = 10;

============================== Step 7 ==============================
Статические методы

Статические методы --  это функции, определённые внутри класса и имеющие
доступ к закрытым полям и методам.

То есть это типа обычной глобальной функции, которая имеет доступ к
private полям класса (в теории даже если они не статические). Объект в
этом случае не нужен!

Объявление:
struct User { 
  ...
static size_t count() { return instances_; } 
private:
  static size_t instances_; 
};

Для вызова статических методов не нужен объект.
  cout << User :: count ();

============================== Step 8 ==============================
Ключевое слово inline

Советует компилятору встроить данную функцию.

Встраивание -- замена формльного вызова функции на тело функции.
Нужно для очень простых функций, для которых неразумно вызывать
множество накладных расходов, характерных для обычных функций
(положить на стек, изменить поинтеры стека и т.д.)

inline double square(double x) { return x * x; }

• В месте вызова inline-функции должно быть известно её определение.

• inline функции можно определять в заголовочных файлах.

• Все методы, определённые внутри класса, являются inline.

• При линковке из всех версий inline-функции (т.е. её код из разных
единиц трансляции) выбирается только одна.

• Все определения одной и той же inline-функции должны быть
идентичными.

• inline --  это совет компилятору, а не указ.

============================== Step 9 ==============================
Правило одного определения

Правило одного определения (One Definition Rule, ODR)

• В пределах любой единицы трансляции (одного файла с кодом) сущности
не могут иметь более одного определения. (Например, нельзя в одном
файле определить одну и ту же переменную дважды. Или, например, можно
объявить одну и ту же функцию несколько раз, но определять можно
только один раз)

Здесь ошибка проявляется на этапе компиляции

• В пределах программы (во всех единицах трансляции) глобальные
переменные и не-inline функции не могут иметь больше одного
определения.

Здесь ошибка проявляется на этапе линковки

• Классы и inline функции могут определяться в более чем одной единице
трансляции (т.е. в рамках программы), но определения обязаны совпадать.

Вопрос: к каким проблемам может привести разные определения одного
класса в разных частях программы?

============================== Step 10 ==============================

В заголовочном файле foo.hpp есть определение функции:

void foo(int i) { std::cout << "i = " << i << std::endl; }

В программе есть три корректных файла с кодом first.cpp, second.cpp и
third.cpp, которые подключают foo.hpp. Отметьте все верные утверждения
из списка:

Ответ:
* на этапе компоновки возникает ошибка из-за множественного
определения функции foo 
* first.cpp, second.cpp и third.cpp компилируются без проблем 

============================== Step 11 ==============================
В заголовочном файле foo.hpp есть определение функции:

static void foo(int i) { std::cout << "i = " << i << std::endl; }

В программе есть три корректных файла с кодом first.cpp, second.cpp и
third.cpp, которые подключают foo.hpp. Отметьте все верные утверждения
из списка:

* все файлы компилируются и компонуются без проблем, в итоговой
программе будет 3 версии функции foo 

* файлы first.cpp, second.cpp и third.cpp компилируются без проблем 

============================== Step 12 ==============================
В заголовочном файле count.hpp определена следующая функция:

static int count() {
    static int counter = 0;
    return ++counter;
}

Этот файл подключается тремя файлами foo.cpp, bar.cpp и
zoo.cpp. Сколько различных экземпляров переменной counter будут
существовать в программе?

Ответ: 3

Надо помнить, что подключение hpp это просто замена ручного
копирования в разные файлы одних и тех же определений!

https://stackoverflow.com/questions/780730/c-c-static-function-in-header-file-what-does-it-mean

============================== Step 13 ==============================
В заголовочном файле foo.hpp есть определение функции:

inline void foo(int i) { std::cout << "i = " << i << std::endl; }

В программе есть три корректных файла с кодом first.cpp, second.cpp и
third.cpp, которые подключают foo.hpp. Отметьте все верные утверждения
из списка:

Ответ:

* программа компилируется и компонуется без проблем 

* файлы first.cpp, second.cpp и third.cpp компилируются без проблем 

* при компоновке лишние определения функции foo будут отброшены

============================== Step 14 ==============================
В заголовочном файле count.hpp определена следующая функция:

inline int count() {     
  static int counter = 0;     
  return ++counter;
}

Этот файл подключается тремя файлами foo.cpp, bar.cpp и
zoo.cpp. Сколько различных экземпляров переменной counter будут
существовать в программе?

Ответ: 1

Потому что При линковке из всех версий inline-функции (т.е. её код из
разных единиц трансляции) **выбирается только одна**.  Кроме того,
здесь static int определена внутри фукнции, и она будет статической
локальной переменной. Время жизни такой переменной --  от первого вызова
функции count до конца программы.

============================== Step 15 ==============================

В заголовочном файле count.hpp определена следующая функция:

inline static int count() {     
  static int counter = 0;     
  return ++counter; 
}

Этот файл подключается тремя файлами foo.cpp, bar.cpp и
zoo.cpp. Сколько различных экземпляров переменной counter будут
существовать в программе?

Ответ: 3

Подсказка: в данном случае штдшту воспринимается как подсказка для
встраивания, но не больше
