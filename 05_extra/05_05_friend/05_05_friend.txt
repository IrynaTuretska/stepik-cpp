============================== Step 2 ==============================
Дружественные классы

Есть класс String, и есть класс StringBuffer.
Мы хотим предоставить StringBuffer доступ к private полям String, но
не хотим делать это для других (то есть не хотим делать их public или
соединять два этих класса наследованием и открывать поля через
protected). Тогда используется ключевое слово friend и делается его
опеределение внутри класса String.


struct String { 
  ...
  friend struct StringBuffer; 
private:
  char * data_;
  size_t len_; 
};

struct StringBuffer {
  void append(String const& s) {
    append(s.data_); 
  }

  void append(char const* s) {...}
  ... 
};

============================== Step 3 ==============================
Дружественные функции

Аналогично предыдущему, только для внешних функций -- так они могут
получать доступ к приватным полям класса!

Дружественные функции можно определять прямо внутри описания класса
(они становятся inline).

struct String { 
  ...
  // тут сразу определение функции, поэтому она станет inline
  friend std::ostream& 
    operator <<(std::ostream & os,
                StringBuffer const& sb) 
  { 
    return os << sb.data_;
  }
private:
  char * data_;
  size_t len_; 
};

============================== Step 4 ==============================
Дружественные методы


Другой класс сможет обращаться к приватным полям другого класса только
внутри метода, который определен в том классе, как дружественный

struct String;
struct StringBuffer {
  void append(String const& s); 
  void append(char const* s) {...} 
  ...
};

struct String { 
  ...
  // только объявление
  friend
    void StringBuffer::append(String const& s);
};

// если определять функцию ниже в hpp, то надо ее определять как inline
void StringBuffer::append(String const& s) { 
  append(s.data_);
}

============================== Step 5 ==============================
Отношение дружбы

Отношение дружбы можно охарактеризовать следующими утверждениями:
• Отношение дружбы не симметрично.
А - друг В не значит, что В друг А

• Отношение дружбы не транзитивно.
А друг В,а В друг С, то это не значит, что А друг С

• Отношение наследования не задаёт отношение дружбы.
• Отношение дружбы сильнее, чем отношение наследования.

Вывод
Стоит избегать ключевого слова friend, так как оно нарушает
инкапсуляцию. (Особенно касается дружественного класса! Лучше сделать
дружественную функцию или метод, чем весь класс)
