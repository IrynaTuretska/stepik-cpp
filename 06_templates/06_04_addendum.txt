============================== Step 2 ==============================
Нетиповые шаблонные параметры

Параметрами шаблона могут быть типы, целочисленные значения,
указатели/ссылки на значения **с внешней линковкой** и шаблоны.

template <class T, size_t N, size_t M>
struct Matrix {
  ...
  T & operator()(size_t i, size_t j) 
  { return data_[M * j + i]; }
private:
  T data_[N * M];
};

// Хотим умножать две матрицы A_{N*M} * A_{M*K} = A_{N*K}
// Значения целочисленных шаблонных параметров дллжно быть известно на
// этапе компиляции

template<class T, size_t N, size_t M, size_t K> 
Matrix<T, N, K> operator*(Matrix<T, N, M> const& a,
	     	         Matrix <T, M, K> const& b);

// указатели и ссылки на значения с внешней линковкой -- то есть они
// тоже должны быть известны на этапе компиляции. Это могут быть
// глобальные переменные или статическое поле класса, которое по сути
// является глобальной переменной

// log - это глобальная переменная

// то есть у нас в программе зашиты данные о том, куда логгер будет
// писать выход. Тогда можно ссылку на глобальную переменную с адресом
// файла передать в ссылки в параметре шаблона

template<ofstream & log>
struct FileLogger { ... };

============================== Step 3 ==============================
Реализуйте функцию array_size, которая возвращает размер массива,
переданного в качестве параметра. Функция должна работать только для
массивов! Т. е. если функции передать указатель, должна произойти
ошибка компиляции. Примеры:

int ints[] = {1, 2, 3, 4};
int *iptr = ints;
double doubles[] = {3.14};
array_size(ints); // вернет 4
array_size(doubles); // вернет 1
array_size(iptr); // тут должна произойти ошибка компиляции

Hint: в одной из первых недель мы вам показывали трюк с передачей
массивов только заданного размера в функцию (передача массива по
ссылке), совместите его с вашими знаниями о шаблонах.

Sample Input:
There are no tests for this task

Sample Output:
OK

Memory Limit: 256 MB
Time Limit: 5 seconds 

Signature:

#include <cstddef> // size_t

// реализуйте шаблонную функцию array_size,
// которая возвращает значение типа size_t.

// put your code here


Source: arrsize.cpp

============================== Step 4 ==============================
Шаблонные параметры — шаблоны

// int –> string
string toString( int i );

// Теперь принимаем массив интов и возвращаем массив строк
// работает только с Array<>
Array<string> toStrings( Array<int> const& ar ) { 
  Array<string> result(ar.size());
  for (size_t i = 0; i != ar.size(); ++i)
    result.get(i) = toString(ar.get(i)); 
  return result;
}

// Напишем шаблон для работы любого контейнера интов (вектор, встроенные
// массивы, ...), который возвращает другой контейнер (может быть
// другого типа!) от строк

// От такого контейнера требуются: конструктор от size, методы size()
// и get()

// Определяем шаблонную функцию, параметром шаблона будет тоже шаблон
// Будет работать для любого *шаблонного контейнера*

template <template <class > class Container > 
Container<string> toStrings( Container<int> const& c) {
  Container<string> result(ar.size()); 
  for (size_t i = 0; i != ar.size(); ++i)
    result.get(i) = toString(ar.get(i)); 
  return result;
}

============================== Step 5 ==============================

Использование зависимых имён
template <class T>
struct Array {
  typedef T value_type; // типичное имя для типа синонимов,
  // определяемых в шаблонах контейнеров
  // Теперь для конкретного контейнера можно писать так:
  // Array<int>::value_type --  будет соответствовать типу int
  // Это нужно для использования внутри шаблонов функций, классов,
  // методов. Например, так по типу контейнера можно будет получить
  // тип элемента, который в нем хранится

  ... 
private:
  size_t size_;
  T * data_; 
};

template <class Container>
bool contains(Container const& c,
              typename Container::value_type const& v);
// обязательно использовать ключевое слово typename

int main () {
  Array<int> a(10);
  contains(a, 5);
  return 0;
}

============================== Step 6 ==============================
Использование функций для вывода параметров

template<class First, class Second>
struct Pair {
  Pair(First const& first , Second const& second) 
  : first(first), second(second) {}
  First first;
  Second second; 
};

template<class First, class Second>
Pair<First, Second> makePair(First const& f, Second const& s) {
  return Pair <First , Second >(f, s); 
}

void foo(Pair<int, double> const& p);

void bar() {
  foo(Pair<int, double>(3, 4.5)); 
  foo(makePair(3, 4.5));
}

============================== Step 7 ==============================
Компиляция шаблонов

∙ Шаблон независимо компилируется для каждого значения шаблонных
параметров.

∙ Компиляция (инстанциирование) шаблона происходит в точке первого
использования — точке инстанциирования шаблона.

Первое упоминание: Array<double> ad(10); - это точка инстанциирования
шаблона Array для типа дабл.
Если второй строчкой будет Array<double> bd(20); то инстанциировать
уже ничего не придется.

∙ Компиляция шаблонов классов — ленивая, компилируются только те
методы, которые используются! Важно явно тестировать все методы!

∙ В точке инстанциирования шаблон должен быть полностью определён.

∙ Шаблоны следует определять в заголовочных файлах.

∙ Все шаблонные функции (свободные функции и методы)
являются inline.

∙ В разных единицах трансляции инстанциирование происходит независимо.

============================== Step 8 ==============================
Резюме про шаблоны

∙ Большие шаблонные классы следует разделять на два заголовочных
файла: объявление (array.hpp) и определение (array_impl.hpp).

В конце файла array.hpp пишем #include "array_impl.hpp"
А потом в программе подключаем только array.hpp

∙ Частичная специализация и шаблонные параметры по умолчанию есть
только у шаблонов классов.

∙ Вывод шаблонных параметров есть только у шаблонов функций.

∙ Предпочтительно использовать перегрузку шаблонных функций
вместо их полной специализации.

∙ Полная специализация функций — это обычные функции.

∙ Виртуальные методы, конструктор по умолчанию, конструктор
копирования, оператор присваивания и деструктор не могут быть
шаблонными.

∙ Используйте typedef для длинных шаблонных имён.

