============================== Step 2 ==============================
Полная специализация шаблонов: классы

template <class T> 
struct Array {
  ...
  T * data_; };

template <>
struct Array <bool > {
  static int const INTBITS = 8 * sizeof(int);  // * * 4 = 32
  explicit Array(size_t size)
    : size_(size)
    , data_(new int[size_ / INTBITS + 1]) // 1000 / 32 + 1
    {}

bool operator []( size_t i) const { // в не константной версии должны
  // вернуть ссылку, но мы не можем вернуть ссылку на конкретный бит
  // пусть i = 100. В каком инте искать бит? 100 / 32 = 3 -- в 3-м
  // инте
  // 100 % 32 = 4 - 4-й бит из инта с номером 3
  // Чтобы получить этот бит побитово умножаем на маску, полученную от
  // сдвига 0x00..10000
  // return ненулевое значение приведет к true, а нулевое к false
  return data_[i / INTBITS] & (1 << (i % INTBITS)));
} 

private:
  size_t size_;
  int * data_; 
};

Сколько памяти на куче нам понадобится, чтобы хранить массив типа Т?
размер типа Т  количество элементов массива 
   sizeof(T) * size =

Если Т = double, а в массиве 1000 элементов -> 8 * 1000 = 8000 байт
T = bool -> 
sizeof(bool) >= 1 байт
>= 1000 байт
Логически, нам для хранения типа bool было бы достаточно 1 бита.
Тогда на массив мы бы потратили в 8 раз меньше места = 1000 / 8 = 125
байт

template<> - пустой список параметров обозначает полную специализацию
шаблона 


============================== Step 3 ==============================
Полная специализация шаблонов: функции

// работает для всех типов, у которых есть конструтор копирования и
// оператор присваивания 
template <class T>
void swap(T & a, T & b) {
  T tmp(a); 
  a = b;
  b = tmp;
}

// у типа Databse оператор присваивания запрещен, но есть метод swap
template<>
void swap<Database>(Database & a, Database & b) {
  a.swap(b); 
}

// У типа могут быть консктруктор копирования и оператор присваивания,
// но они трудоемкие, и получается, что для того, чтобы поменять две
// переменные местами, надо выполнять много работы -- например, класс
// массива. Если будет пользоваться первой функцией своп для массива,
// получится, что мы массивы трижды скопируем -- много расходов

// Кроме того, класс может быть еще и шаблонным. И для таких классов
// надо определять не специализацию шаблона, а перегрузку

template <class T>
void swap(Array <T> & a, Array<T> & b {
  a.swap(b); 
}

============================== Step 4 ==============================
Специализация шаблонов функций и перегрузка

// 1. Шаблонная функция
template <class T>
void foo(T a, T b) {
  cout << "same types" << endl; 
}

// 2. Перегрузка шаблонной функции
template <class T, class V> 
void foo(T a, V b) {
  cout << "different types" << endl; 
}

// 3. Полная специализация функции 2 для случая, когда оба типа равны
// int
template <>
void foo<int, int>(int a, int b) {
  cout << "both parameters are int" << endl; 
}

int main() { 
  foo(3, 4); // Какая функция будет вызвана? Ответ: 1
  // чтобы вызвать 3-ю, надо явно указать шаблоанные параметры
  // foo<int, int>(3, 4)

  // Почему?  
  // сначала обрабатывается перегрузка (функции 1 и 2), а только потом
  // специализация. Из ф-ций 1 и 2 больше всего подходит 1, потому что
  // там оба аргумента одного типа
  // Поэтому использование полной специализации -- спорный момент,
  // разумнее использовать перегрузки

  return 0; 
}

============================== Step 5 ==============================
Частичная специализация шаблонов

Для классов не бывает перегрузки, поэтому используют либо
специализацию либо частичную специализацию -- последяя позволяет
эмулировать подобие перегрузки для класса: то есть есть шаблон класса
по умолчанию и несколько шаблонов "перегрузок" (полная или частичная
специализация)

Пример. Шаблонный класс массива, который мы будем специализировать

template <class T>
struct Array {
  T & operator[](size_t i) { return data_[i]; }
  ... 
};

// частичная специализация -- когда в качестве шаблонного параметра
// передают массив указателей любого типа

template <class T>
struct Array <T *> {
  explicit Array(size_t size) 
   : size_(size)
   , data_(new T *[size_]) {}

// разыменовываем
T & operator[](size_t i) { return *data_[i]; }

private:
  size_t size_;
  T ** data_; 
};

============================== Step 6 ==============================
Специализация шаблонов для получения информации о типах используется в
C++ довольно активно. Например, для простых типов вроде char или int
функция copy_n (которую вы реализовали раньше) может использовать
memcpy. Использование memcpy может оказаться быстрее, чем поэлементное
копирование массива.

Давайте создадим шаблон TriviallyCopyable, который позволит узнать,
допустимо ли для данного типа побайтовое копирование вместо вызова
конструктора копирования или оператора присваивания. Как может
выглядеть такой шаблон:

template <typename T>
struct TriviallyCopyable
{ static const bool value = false; };

Если значение value == true, значит для копирования можно использовать
memcpy. В шаблоне выше значение value по умолчанию равно false, потому
что безопасно считать, что тип нельзя копировать с использованием
memcpy (возможно, мы немного проиграем от этого в скорости, но не в
правильности).

Функция copy_n может теперь использовать значение
TriviallyCopyable<T>::value, чтобы выбрать общую реализацию или
реализацию с использованием memcpy. Однако, чтобы от TriviallyCopyable
была польза, нужно специализировать его так, чтобы для простых типов
value было равно true, например, так:

template <> struct
TriviallyCopyable<char>
{ static const bool value = true; };

Аналогичным образом, мы можем специализировать TriviallyCopyable для
типов (классов), определенных пользователем (если их, конечно,
действительно можно копировать с использованием memcpy). Выигрыш по
сравнению со специализацией/перегрузкой функции copy_n заключается в
том, что класс TriviallyCopyable может использовать не только copy_n,
а любая другая функция или класс, для которой эта информация может
оказаться полезной.

============================== Step 7 ==============================
В качестве упражнения на частичную специализацию шаблонов классов вам
предлагается реализовать простой шаблон SameType. Этот шаблон не
содержит никаких методов, а только одно статическое константное поле
типа bool, с именем value. Шаблон принимает два типовых параметра, и
если два типовых параметра шаблона являются одним и тем же типом, то
статическое поле value должно хранить значение true, в противном
случае значение false. Примеры:

struct Dummy { };
typedef int type;

std::cout << SameType<int, int>::value << std::endl; // выведет 1,
т. е. true
std::cout << SameType<int, type>::value << std::endl; // 1, type ==
int
std::cout << SameType<int, int&>::value << std::endl; // 0, int и
ссылка на int - различные типы
std::cout << SameType<Dummy, Dummy>::value << std::endl; // 1
std::cout << SameType<int, const int>::value << std::endl; // 0, const
- часть типа

Hint: задание простое, решение занимает порядка десяти строк кода.

Sample Input:
There are no tests for this task

Sample Output:
OK

Memory Limit: 256 MB
Time Limit: 5 seconds 

Signature:
// Определите шаблон SameType с двумя типовыми
// параметрами. В шаблоне должна быть определена
// одна статическая константа типа bool с именем
// value

Source: sametype.cpp
