============================== Step 2 ==============================
Шаблоны функций: возведение в квадрат

// C
int squarei(int x) { return x * x; }
float squaref(float x) { return x * x; }

// C++ с перегрузкой
int square(int x) { return x * x; }
float square(float x) { return x * x; }
Минусы:
 - дублирование кода

// C++ + OOP
struct INumber { 
  virtual INumber * multiply (INumber * x) const = 0;
};

struct Int : INumber { ... };
struct Float : INumber { ... };
INumber * square(INumber * x) { return x->multiply(x); }
Минусы:
 - приходится делать много оберток для встроенных типов
 - потеря производительности за счет работы с кучей

// C++ + templates
template <typename Num>
Num square(Num x) { return x * x; }
Плюс:
 - проще
 - не надо дублировать код


============================== Step 3 ==============================
Шаблоны функций: сортировка

// C
void qsort(void * base, size_t nitems, size_t size, /*function*/);

void * base - позволяет передать любой массив любого типа
но при этом передается массив как просто массив байтов,
поэтому надо передавать размер одного элемента (третий аргумент
функции).
В качестве четвертого аргумента передается функция сравнения двух
элементов. Потому что элементы массива могут быть самых разных типов.

Кьюсорт имеет указатель на массив, знает количество элементов массива,
размер одного элемента, а также имеет указатель на функцию для
сравнения элементов. Поэтому мы побайтово можем копировать и
переставлять элементы массива. Но это приведет к неопределенному
поведению в случае, когда элементами массива являются объекты. Потому
что в этом случае надо работать с конструкторами этих
объектов. Поэтому в данном случае функция сортировки не типобезопасна,
потому что не работает с пользовательскими типами и классами!

// C++
void sort(int * p, int * q); 
void sort(double * p, double * q);

В этом случае придется писать функцию для каждого типа

// C++ + OOP
struct IComparable {
  virtual int compare(IComparable * comp) const = 0; 
  virtual ~IComparable() {}
};

void sort(IComparable ** p, IComparable ** q);

Выделяем интерфейс, который будут поддерживать все классы, для которых
мы хотим иметь возможность запихивать их в функцию sort.

Потом определяем функцию sort, которая будет сортировать массив
указателей на объекты, поддерживающие наш интерфейс.

Плюс: нужна только одна функция сортировки

Минус: много накладных расходов, потому что работаем с указателями,
изменяем все классы и для встроенных классов придется писать обертки,
которые тоже поддерживают интерфейс.

Почему у ООП-ного сорта оба параметра двойные указатели?
Потому что подразумевается указатель на массив указателей на
IComparable. 

// C++ + templates
template <typename Type >
void sort(Type * p, Type * q);

Эта шаблонная функция будет работать для всех типов, для которых
работает оператор меньше <

Плюс: просто и эффективно (без оберток)

NB: у шаблонных функций нет параметров по умолчанию!

Для шаблонных функций существует перегрузка -- поэтому можно
определить просто несколько шаблонных функция с одинаковым именем. Так
можно сделать, чтобы какая-то функция имела меньше шаблонных
параметров (тогда просто перегружаем ее).

============================== Step 4 ==============================
Реализуйте функцию копирования элементов copy_n из массива источника
типа U* в целевой массив типа T*, где T и U произвольные типы, для
которых определено преобразование из U в T. На вход функция принимает
два указателя и количество элементов, которые необходимо скопировать.

Пример вызова функции copy_n:

int ints[] = {1, 2, 3, 4};
double doubles[4] = {};
copy_n(doubles, ints, 4); // теперь в массиве doubles содержатся
элементы 1.0, 2.0, 3.0 и 4.0

Sample Input:
There are no tests for this task

Sample Output:
OK

Memory Limit: 256 MB
Time Limit: 5 seconds 

Signature:

#include <cstddef>

// Параметры функции copy_n идут в следующем
// порядке:
//   1. целевой массив
//   2. массив источник
//   3. количество элементов, которые нужно
//      скопировать
//
// Вам нужно реализовать только функцию copy_n,
// чтобы ее можно было вызвать так, как показано
// в примере.

// put your code here

Source: copyn.cpp

============================== Step 5 ==============================
Вывод аргументов (deduce)

template <typename Num>
Num square(Num n) { return n * n; }

template <typename Type >
void sort(Type * p, Type * q);

template <typename Type> 
void sort(Array<Type> & ar);

void foo() { 
  int a = square <int >(3);
  int b = square(a) + square(4); // компилятор догадается до 
      	  	      		 // square<int>(..)
  float * m = new float [10];
  sort(m, m + 10); &a); // sort<float>(m, m + 10)
  sort(m, &a); // error: sort<float> vs. sort<int>
  Array<double> ad(100);
  sort(ad); // вызывается перегрузка функции sort для массивов,
  	    // компилятор определяет тип sort<double>(ad)
}

============================== Step 6 ==============================

На предыдущей неделе вы познакомились с перегрузкой операторов. Среди
перегружаемых операторов в C++ есть оператор (). Рассмотрим пример
перегрузки:

struct Less { 
    bool operator()(int a, int b) const { return a < b; } 
};

Создадим объект Less и назовем его less. Использование этого объекта
синтаксически выглядит как вызов функции:

if (less(10, 20)) 
    std::cout << "10 < 20" << std::endl;
else 
    std::cout << "10 >= 20" << std::endl;

Если заменить объект less на функцию с тем же именем:

bool less(int a, int b) { return a < b; }

то код выше не потребует никаких изменений. Однако, хотя в обоих
случаях объекты имеют одно и то же имя (less), их типы отличаются. 

============================== Step 7 ==============================
Шаблоны помогают преодолеть различие между объектами и
функциями. Можно добавить в функции sort дополнительный параметр,
который задаёт отношение меньше:

template<class T, class Comp>
void sort(T * p, T * q, Comp less);


В качестве третьего параметра в эту функцию Вы можете передать как
функцию (на самом деле при этом будет передан указатель на функцию),
так и объект класса с перегруженным оператором  "()"). И при этом вам
не нужно знать его конкретный тип, важно лишь то, что его
использование синтаксически похоже на вызов функции.

int m[10] = {0,1,2,3,4,5,6,7,8,9};

sort(m, m + 10, Less()); // передаём объект типа Less
sort(m, m + 10, less);   // передаём функцию less с предудыщего степа

============================== Step 8 ==============================
Реализуйте шаблонную функцию minimum, которая находит минимальный
элемент, который хранится в экземпляре шаблонного класса Array, при
этом типовой параметр шаблона Array может быть произвольным. Чтобы
сравнивать объекты произвольного типа, на вход функции так же будет
передаваться компаратор, в качестве компаратора может выступать
функция или объект класса с перегруженным оператором "()". Примеры
вызова функции minimum:

bool less(int a, int b) { return a < b; }
struct Greater { bool operator()(int a, int b) { return b < a; } };

Array<int> ints(3);
ints[0] = 10;
ints[1] = 2;
ints[2] = 15;
int min = minimum(ints, less); // в min должно попасть число 2
int max = minimum(ints, Greater()); // в max должно попасть число 15

Sample Input:
There are no tests for this task

Sample Output:
OK

Memory Limit: 256 MB
Time Limit: 5 seconds 

Signature:
#include <cstddef>

template <typename T>
class Array
{
public:
	explicit Array(size_t size = 0, const T& value = T());
	Array(const Array& other);
	~Array();
	Array& operator=(Array other);
	void swap(Array &other);
	size_t size() const;
	T& operator[](size_t idx);
	const T& operator[](size_t idx) const;

private:
	size_t size_;
	T *data_;
};

// put your code here

Source: minimum.cpp

============================== Step 9 ==============================


Шаблонный класс Array может хранить объекты любого типа, для которого
определён конструктор копирования, в том числе и другой Array,
например, Array< Array<int> >. Глубина вложенности может быть
произвольной. Напишите шаблонную функцию (или несколько) flatten,
которая принимает на вход такой "многомерный" Array неизвестной
заранее глубины вложенности и выводит в поток out через пробел все
элементы, хранящиеся на самом нижнем уровне. Примеры работы функции
flatten:

Array<int> ints(2, 0);
ints[0] = 10;
ints[1] = 20;
flatten(ints, std::cout); // выводит на экран строку "10 20"

Array< Array<int> > array_of_ints(2, ints);
flatten(array_of_ints, std::cout); // выводит на экран строку "10 20
10 20"

Array<double> doubles(10, 0.0);
flatten(doubles, std::cout); // работать должно не только для типа int

Note: лидирующие и завершающие пробельные символы будут игнорироваться
проверяющей системой, т. е. там где ожидается "10 20" будет так же
принят, например, вариант "   10 20   ", но не вывод "1020".

Hint: шаблонные функции тоже можно перегружать, из нескольких
шаблонных функций будет выбрана наиболее специфичная.

Sample Input:
There are no tests for this task

Sample Output:
OK

Memory Limit: 256 MB
Time Limit: 5 seconds 

Signature:
#include <iostream>


// Весь вывод должен осущствляться в поток out,
// переданный в качестве параметра.
//
// Можно заводить любые вспомогаетльные функции,
// структуры или даже изменять сигнатуру flatten,
// но при этом все примеры вызова из задания должны
// компилироваться и работать.

template <typename T>
void flatten(const Array<T>& array, std::ostream& out)
{ }

Source: flatten.cpp

============================== Step 10 ==============================
Шаблоны методов

template <class Type> 
struct Array {
  // Позволит сделать так:
  // Array<int> a;
  // Array<double> b(a); -- приведение из инт к дабл
  // Обратное преобразование будет и при исп-нии оператора
  // присваивания:
  // a = b;
  template<class Other>
  Array( Array <Other > const& other)
  : data_(new Type[other.size()])
  , size_(other.size()) {
  for(size_t i = 0; i != size_; ++i)
    data_[i] = other[i];
  }

  template<class Other>
  Array & operator=(Array<Other> const& other); 
  ...
};

/*
Шаблонные методы шаблонного класса можно определять и снаружи! (то
есть вне самого класса). Для этого надо задать два шаблонных
заголовка: заголовок самого класса и заголовок метода.
При этом нужно указывать *полное* название типа!ч
*/

template<class Type>
template<class Other>
Array<Type> & Array<Type>::operator=(Array<Other> const& other) 
{ ... return *this; }

Конструктор по умолчанию, конструктор копирования, оператор
присваивания, деструктор -- эти методы не могут быть шаблонными. Их
надо определять нешаблонно

Также не могут быть шаблонными виртуальные методы.

============================== Step 11 ==============================


В первом уроке вы реализовали простой шаблон ValueHolder, в этом
задании мы используем его чтобы написать класс Any (интересно, что не
шаблонный), который позволяет хранить значения любого типа! Например,
вы сможете  создать массив объектов типа Any, и сохранять в них int-ы,
double-ы или даже объекты Array. Подробности в шаблоне кода. Hint: в
нешаблонном классе Any могут быть шаблонные методы, например,
шаблонный конструктор.

Sample Input:
There are no tests for this task

Sample Output:
OK

Memory Limit: 256 MB
Time Limit: 5 seconds 

Signature:
// Эти классы реализовывать заново не нужно
struct ICloneable;

// Поле data_ типа T в классе ValueHolder
// открыто, к нему можно обращаться
template <typename T>
struct ValueHolder;

// Это класс, который вам нужно реализовать
class Any
{
    // В классе Any должен быть конструктор,
    // который можно вызвать без параметров,
    // чтобы работал следующий код:
    //    Any empty; // empty ничего не хранит

    // В классе Any должен быть шаблонный
    // конструктор от одного параметра, чтобы
    // можно было создавать объекты типа Any,
    // например, следующим образом:
    //    Any i(10); // i хранит значение 10

    // Не забудьте про деструктор. Все выделенные
    // ресурсы нужно освободить.

    // В классе Any также должен быть конструктор
    // копирования (вам поможет метод clone
    // интерфейса ICloneable)

    // В классе должен быть оператор присваивания и/или
    // шаблонный оператор присваивания, чтобы работал
    // следующий код:
    //    Any copy(i); // copy хранит 10, как и i
    //    empty = copy; // empty хранит 10, как и copy
    //    empty = 0; // а теперь empty хранит 0

    // Ну и наконец, мы хотим уметь получать хранимое
    // значение, для этого определите в классе Any
    // шаблонный метод cast, который возвращает
    // указатель на хранимое значение, или нулевой
    // указатель в случае несоответствия типов или
    // если объект Any ничего не хранит:
    //    int *iptr = i.cast<int>(); // *iptr == 10
    //    char *cptr = i.cast<char>(); // cptr == 0,
    //        // потому что i хранит int, а не char
    //    Any empty2;
    //    int *p = empty2.cast<int>(); // p == 0
    // При реализации используйте dynamic_cast,
    // который мы уже обсуждали ранее.
};

Source: any.cpp

